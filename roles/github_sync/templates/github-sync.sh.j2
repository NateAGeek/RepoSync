#!/bin/bash
# GitHub Repository Sync Script
# Generated by Ansible - do not edit manually
#
# This script safely pulls new commits from remote repositories.
# It will SKIP any repo that has local changes - never commits, merges, or modifies.

set -euo pipefail

TIMESTAMP=$(date '+%Y-%m-%d %H:%M:%S')
LOG_PREFIX="[${TIMESTAMP}]"
FAILED_REPOS=()
SKIPPED_REPOS=()

# SSH key setup
export GIT_SSH_COMMAND="ssh -i {{ (github_repos_owner == 'root') | ternary('/root', '/home/' + github_repos_owner) }}/.ssh/{{ github_ssh_key_name }} -o StrictHostKeyChecking=accept-new"

log() {
    echo "${LOG_PREFIX} $1"
}

log_warn() {
    echo "${LOG_PREFIX} WARN: $1"
}

log_error() {
    echo "${LOG_PREFIX} ERROR: $1" >&2
}

sync_repo() {
    local repo_path="$1"
    local repo_name=$(basename "$repo_path")
    local branch="$2"
    
    if [[ ! -d "$repo_path/.git" ]]; then
        log_error "Not a git repository: $repo_path"
        return 1
    fi
    
    cd "$repo_path"
    
    # Check for any local modifications (staged, unstaged, or untracked)
    if ! git diff --quiet HEAD 2>/dev/null; then
        log_warn "Skipping ${repo_name} - has uncommitted changes"
        SKIPPED_REPOS+=("$repo_path")
        return 0
    fi
    
    # Check for staged changes
    if ! git diff --cached --quiet 2>/dev/null; then
        log_warn "Skipping ${repo_name} - has staged changes"
        SKIPPED_REPOS+=("$repo_path")
        return 0
    fi
    
    # Check if we're on the expected branch
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
    if [[ "$current_branch" != "$branch" ]]; then
        log_warn "Skipping ${repo_name} - on branch '${current_branch}', expected '${branch}'"
        SKIPPED_REPOS+=("$repo_path")
        return 0
    fi
    
    # Check if there are any local commits not on remote
    git fetch origin "$branch" --quiet
    local local_commit remote_commit
    local_commit=$(git rev-parse HEAD)
    remote_commit=$(git rev-parse "origin/${branch}")
    
    # Check if local is ahead of remote (has local commits)
    if [[ $(git rev-list --count "origin/${branch}..HEAD") -gt 0 ]]; then
        log_warn "Skipping ${repo_name} - has local commits not pushed to remote"
        SKIPPED_REPOS+=("$repo_path")
        return 0
    fi
    
    # Check if already up to date
    if [[ "$local_commit" == "$remote_commit" ]]; then
        log "${repo_name} is already up to date"
        return 0
    fi
    
    # Safe to pull - only fast-forward, no merge commits
    log "Pulling ${repo_name} (${branch})..."
    if git pull --ff-only origin "$branch"; then
        local new_commit
        new_commit=$(git rev-parse --short HEAD)
        log "Successfully updated ${repo_name} to ${new_commit}"
    else
        log_error "Failed to pull ${repo_name} - fast-forward not possible"
        return 1
    fi
    
    return 0
}

log "Starting GitHub sync (safe mode - no merges, no commits)..."

{% for repo in github_repos %}
if ! sync_repo "{{ repo.dest }}" "{{ repo.version | default('main') }}"; then
    FAILED_REPOS+=("{{ repo.dest }}")
fi

{% endfor %}

# Summary
if [[ ${#SKIPPED_REPOS[@]} -gt 0 ]]; then
    log_warn "Skipped ${#SKIPPED_REPOS[@]} repo(s) with local changes: ${SKIPPED_REPOS[*]}"
fi

if [[ ${#FAILED_REPOS[@]} -gt 0 ]]; then
    log_error "Sync completed with errors. Failed repos: ${FAILED_REPOS[*]}"
{% if github_sync_notify_on_failure and github_sync_slack_webhook %}
    # Send Slack notification
    curl -s -X POST -H 'Content-type: application/json' \
        --data "{\"text\":\"GitHub sync failed on $(hostname) for: ${FAILED_REPOS[*]}\"}" \
        "{{ github_sync_slack_webhook }}" || true
{% endif %}
    exit 1
else
    log "Sync complete."
fi
